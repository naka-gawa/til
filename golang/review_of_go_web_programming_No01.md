# [Go プログラミング実践入門](https://www.amazon.co.jp/Goプログラミング実践入門-標準ライブラリでゼロからWebアプリを作る-impress-gearシリーズ-Sheong-Chang-ebook/dp/B06XKPNVWV) 読書メモ

## 第1章Go言語はWebアプリ開発に最適な言語
### 1.1
- Golang は Webアプリを書くのに良い
  - 大規模Webアプリ開発言語には下記が必要でGolangは持っているよ
    - スケーラビリティ
      - ゴルーチン : 複数の処理を同時に実行するfunction
    - モジュール性
      - インターフェイスにより動的な型付けが可能 (空インターフェイス)
    - 高い保守性
      - クリーンでシンプルな構文にできるように、標準モジュールが揃っている
    - 高い実行効率
      - C言語の実行速度に近づく = Golang
### 1.2
- Webアプリケーション is なに?
  - HTTPのリクエストに対してHTMLレスポンスをクライアントに返すプログラム
    - 単純に ディレクトリのHTMLファイルを返すだけだと、Webサーバと大差無い
    - なのでプログラムされた作業を実行し、ファイルを返すってのが大事
  - 呼び出したクライアントにHTMLを返す
  - クライアントはHTMLをレンダリングしユーザーに提示する
  - データはHTTPを使ってクライアントに送信される
### 1.3
- HTTP 0.9 ではステートレスであるが、1.1 では引き回すためステートフルである
- サーバー/クライアント型のリクエストとレスポンスで成立されている
### 1.4
- ファイルを配信するだけだったが、Common Gateway Interface (CGI) で動的にコンテンツが生成されるようになった
- また、Server-Side Includes (SSI) により、リクエストされた際に SSI が実行されてコンテンツが生成される
  - こんなやつらしい
  - ディレクティブが置かれている場所にファイルの内容を挿入するらしい
```
<html>
  <body>
  <!--#include file="hogehoge.shtml"-->
  </body>
</html>
```
### 1.5
- HTTP リクエストは下記から成り立つ
  - リクエスト行
  - リクエストヘッダ
    - HOST や User-Agent 等がある
  - 空行
  - メッセージ本体
  - もちろん前提に3 way hand shake でセッション確立している
- HTTP リクエストメソッドは下記の種類がある
  - GET     : リソースを返すようにサーバ側に依頼する
  - HEAD    : GET と似たようなメソッドだが、メッセージ本体は返さない
  - POST    : メッセージ本体のデータをURIで示されたリソースに渡すようにサーバに指示する
  - PUT     : メッセージ本体のデータをURIで示されたリソースに置き換えるように指示する
  - DELETE  : リソースの削除
  - TRACE   : リクエストを送り返すようにサーバに指示する
  - OPTIONS : サーバがサポートするHTTPメソッドのリストを返すようにサーバに指示する
  - CONNECT : クライアントとのネットワーク接続を準備するようにサーバに指示する
  - PATCH   : URIで指定されたリソースをメッセージ本体のデータに従って変更するようにサーバに指示する
- SAFE と UNSAFE なメソッドがあるよ
  - GET, HEAD, TRACE は SAFE
  - POST, PUT, DELETE は サーバのリソースを変更するので UNSAFE
- 冪等なリクエストメソッドがあると
  - SAFE = 冪等 なメソッド
  - PUT, DELETE = 冪等なメソッドだが、UNSAFE
    - 1回目はサーバリソースを変更するので安全ではない
    - 2回目以降はサーバの状態を変更しない
  - POST = 安全じゃなく冪等でもないメソッド
    - 1回目はサーバに渡すが、その後サーバが処理するので HTTP 的には関知しない
    - なので2回目以降も同じように送られると、変更が走ってしまう
      - なので冪等ではない
- リクエストメソッドに対するブラウザのサポート
  - GET が無いとサーバからコンテンツを取得できないのでサポートしていないブラウザには人権が無い
  - HTMLがサポートしているリクエストメソッドはGETとPOSTのみ
  - 最近のブラウザが処理できるのはHTMLだけではなく、XMLHttpRequest (XHR) を使うことができる
- リクエストヘッダの種類
  - Host           : must サーバ名とポート番号]
  - Accept         : クライアントがレスポンスの一部として受け取ることができるコンテンツタイプ
  - Accept-Charset : サーバから受け取る際に要求する文字セット
  - Authorization  : Basic認証の証明書をサーバに送付する際に使われる
  - Cookie         : クライアントは呼び出し先のサーバが設定したクッキーを送り返さなければならない
  - Content-Length : リクエスト本体の長さ
  - Content-Type   : リクエスト本体のコンテンツタイプ
  - Refferrer      : リクエストされたページにリンクしていた以前のページのアドレス
  - User-Agent     : 呼び出ししているクライアントの情報
### 1.6
- HTTP レスポンスは下記から成り立つ
  - ステータス行
  - レスポンスヘッダ(0 個以上)
  - 空行
  - メッセージ本体
- レスポンスコード
  - 1xx : 情報提供コードでサーバがリクエストを受け取り処理を初めてるよってクライアントに伝えるコード
  - 2xx : 成功コードでクライアントの要求は正常に受け入れられたことを伝えるコード
  - 3xx : 転送コードでリクエストは受け付けられて処理されたがアクションを完遂するにはクライアントがすべきことが残っていることを示すコード
  - 4xx : クライアントエラーで、リクエストに誤りがあったことを通知するコード
  - 5xx : サーバエラーで、リクエストの処理に失敗し、それがサーバー側の不具合によるものであることを伝えるコード
- レスポンスヘッダ
  - Allow            : サーバがどのリクエストメソッドをサポートしているかをクライアントに伝える
  - Content-Type     : リクエストと同じなので省略
  - Content-Length   : リクエストと同じなので省略
  - Date             : 現在の日時 GMTフォーマット
  - Location         : リダイレクションとともに使われて、次のURLをどこに要求すればよいかクライアントに伝える
  - Server           : レスポンスを返しているサーバのドメイン名
  - Set-Cookie       : クライアントへのクッキーを設定する
  - WWW-Authenticate : リクエストヘッダのAuthorizationフィールドにどのような認証情報を含めるべきかをクライアントに伝える
### 1.7
- Uniform Resouce Identifier (URI)
  - インターネット女言うのリソースの位置を文字列で表現する
  - 一般型は `スキーム名 : 階層部 [ ?クエリ] [ #フラグメント]` で構成されている
    - スキーム名は URI構造の残りの部分を定義するURIスキームの名前
    - 階層部は リソースを特定する情報がくる
    - クエリは、キーと値の組になっている
      - 省略可
    - フラグメントは、2次リソースを特定する
      - 省略可
  - [例](https://webtan.impress.co.jp/e/2010/03/09/7539)はこんな感じ
    - http://yasuda:pass@www.example.com:8080/news/index.htm?page=2&msg=yes#hot
    - `http`がスキーム名
    - `yasuda:pass@www.example.com:8080/news/index.htm`が階層部
      - `yasuda:pass@www.example.com:8080` が Authority
      - `/news/index.htm` がパスになる
    - `?page=2&msg=yes` が クエリ
    - `#hot` がフラグメント
### 1.8
- HTTP/2
  - パフォーマンスに優れている
  - HTTP/1.x はテキストベースだったが、HTTP/2.0 はバイナリベース
  - 構文解析の効率が高いが、telnet のようなプロトコルを使っての debug ができなくなった
  - HTTP/1.x は1回の接続で送信できるリクエストは一つに対して、全多重されている
### 1.9
- Webアプリケーションの多くはその性質上、ハンドラとテンプレートエンジンを持つ
  - ハンドラ
    - クライアントから送られてきた HTTP リクエストを受付処理をする
    - 受け付けられたあとはハンドラがテンプレートエンジンを呼び出してHTMLを生成しクライアントに返す
    - Model, View, Controller (MVC) モデル
      - Model      = 利用されるデータ
      - View       = モデルをユーザーに向けて視覚化したもの
      - Controller = ユーザーからの入力によってモデルを変えていくもの
  - テンプレートエンジン
    - クライアントにHTTPレスポンスメッセージを送り返すときに利用されるもの
    - テンプレートは部分的にHTMLになっているものもあるしHTMLをまったく含まないものもある
      - 静的テンプレート
      - アクティブテンプレート
### 1.10
- サンプルアプリケーションの解説
```
package main

import (
    "fmt"
    "net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
  fmt.Fprintf(w, "Hello World, %s", r.URL.Path[1:])
}

func main() {
  http.HandleFunc("/", handler)
  http.ListenAndServe(":8080", nil)
}
```
- `func handler(){}`で関数の定義
  - handler関数には2つの引数を取っている
    - 構造体 `*http.Request`のポインタから情報を取り出して、`http.ResponseWriter`を介して返信される
- main関数
  - ルートURLが呼び出されたとき、handler 関数が起動されるようになっている
  - ListenAndServeで待ち受けるポートを指定している
